"use strict";

require("core-js/modules/es.array.filter.js");

require("core-js/modules/es.object.get-own-property-descriptors.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.array.slice.js");

require("core-js/modules/es.array.from.js");

require("core-js/modules/es.weak-map.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InputTime = exports.convert12To24HrString = void 0;

require("core-js/modules/es.array.map.js");

require("core-js/modules/es.string.split.js");

require("core-js/modules/es.array.includes.js");

require("core-js/modules/es.string.includes.js");

require("core-js/modules/es.string.replace.js");

var _react = _interopRequireWildcard(require("react"));

var _designTokens = require("@looker/design-tokens");

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _noop = _interopRequireDefault(require("lodash/noop"));

var _add = _interopRequireDefault(require("lodash/add"));

var _subtract = _interopRequireDefault(require("lodash/subtract"));

var _InputText = require("../InputText");

var _innerInputStyle = require("../innerInputStyle");

var _simple = require("../../../Layout/utils/simple");

var _InputProps = require("../InputProps");

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const initialState = {
  charCount: 0,
  format: '12h',
  hour: '',
  isComplete: false,
  minute: '',
  period: '',
  subInputFocus: 'NONE'
};

const isNumericKey = e => e.keyCode >= 48 && e.keyCode <= 57 || e.keyCode >= 96 && e.keyCode <= 105;

const isArrowKey = e => e.key === 'ArrowUp' || e.key === 'ArrowDown';

const isDeleteKey = e => {
  return e.key === 'Backspace' || e.key === 'Delete';
};

const selectNextInput = current => {
  switch (current) {
    case 'HOUR':
      return 'MINUTE';

    case 'MINUTE':
      return 'PERIOD';

    case 'PERIOD':
      return 'NONE';

    default:
      return 'NONE';
  }
};

const isInputComplete = ({
  format,
  hour,
  minute,
  period
}) => {
  if (format === '12h') {
    return !!(hour.length && minute.length && period.length);
  }

  return !!(hour.length && minute.length);
};

const reducer = (state, action) => {
  const payload = action.payload,
        type = action.type;
  const inputValues = {
    format: state.format,
    hour: state.hour,
    minute: state.minute,
    period: state.period
  };

  switch (type) {
    case 'SET_FOCUS':
      return _objectSpread(_objectSpread({}, state), {}, {
        subInputFocus: payload
      });

    case 'FOCUS_NEXT_FIELD':
      return _objectSpread(_objectSpread({}, state), {}, {
        subInputFocus: selectNextInput(state.subInputFocus)
      });

    case 'INCREMENT_CHAR_COUNT':
      return _objectSpread(_objectSpread({}, state), {}, {
        charCount: state.charCount + 1
      });

    case 'RESET_CHAR_COUNT':
      return _objectSpread(_objectSpread({}, state), {}, {
        charCount: 0
      });

    case 'SET_HOUR_VALUE':
      return _objectSpread(_objectSpread({}, state), {}, {
        hour: payload,
        isComplete: isInputComplete(_objectSpread(_objectSpread({}, inputValues), {}, {
          hour: payload
        }))
      });

    case 'SET_MINUTE_VALUE':
      return _objectSpread(_objectSpread({}, state), {}, {
        isComplete: isInputComplete(_objectSpread(_objectSpread({}, inputValues), {}, {
          minute: payload
        })),
        minute: payload
      });

    case 'SET_PERIOD_VALUE':
      return _objectSpread(_objectSpread({}, state), {}, {
        isComplete: isInputComplete(_objectSpread(_objectSpread({}, inputValues), {}, {
          period: payload
        })),
        period: payload
      });

    default:
      return state;
  }
};

const cycleValue = (currentValue, key, max, min) => {
  const transform = key === 'ArrowUp' ? _add.default : _subtract.default;
  const newValue = transform((0, _utils.parseBase10Int)(currentValue), 1);

  if (newValue < min) {
    return (0, _utils.formatTimeString)(max);
  } else if (newValue > max) {
    return (0, _utils.formatTimeString)(min);
  } else {
    return (0, _utils.formatTimeString)(newValue);
  }
};

const parseValue = (format, value = '') => {
  if (value.length) {
    const _value$split$map = value.split(':').map(_utils.parseBase10Int),
          _value$split$map2 = _slicedToArray(_value$split$map, 2),
          hr24 = _value$split$map2[0],
          minute = _value$split$map2[1];

    const hr12 = hr24 <= 12 ? hr24 : hr24 - 12;
    const period = hr24 >= 12 ? 'PM' : 'AM';
    return [(0, _utils.formatTimeString)(format === '12h' ? hr12 : hr24), (0, _utils.formatTimeString)(minute), period];
  }

  return ['', '', ''];
};

const convert12To24HrString = value => {
  const period = value.includes('P') ? 'PM' : 'AM';
  const numericTime = value.replace(/[APM]/gi, '');

  const _numericTime$split$ma = numericTime.split(':').map(_utils.parseBase10Int),
        _numericTime$split$ma2 = _slicedToArray(_numericTime$split$ma, 2),
        _numericTime$split$ma3 = _numericTime$split$ma2[0],
        hour = _numericTime$split$ma3 === void 0 ? 0 : _numericTime$split$ma3,
        _numericTime$split$ma4 = _numericTime$split$ma2[1],
        minute = _numericTime$split$ma4 === void 0 ? 0 : _numericTime$split$ma4;

  let hr24;

  if (period === 'AM' && hour === 12) {
    hr24 = 0;
  } else if (period === 'PM' && hour < 12) {
    hr24 = hour + 12;
  } else {
    hr24 = hour;
  }

  return `${(0, _utils.formatTimeString)(hr24)}:${(0, _utils.formatTimeString)(minute)}`;
};

exports.convert12To24HrString = convert12To24HrString;
const InputTimeInternal = (0, _react.forwardRef)(({
  className,
  defaultValue,
  'aria-describedby': ariaDescribedby,
  'aria-labelledby': ariaLabelledby,
  autoFocus,
  disabled,
  format = '12h',
  id,
  onChange,
  readOnly,
  onBlur,
  onFocus,
  onValidationFail,
  required,
  validationType,
  value
}, ref) => {
  const _useReducer = (0, _react.useReducer)(reducer, _objectSpread(_objectSpread({}, initialState), {}, {
    format
  })),
        _useReducer2 = _slicedToArray(_useReducer, 2),
        inputState = _useReducer2[0],
        dispatch = _useReducer2[1];

  const hour = inputState.hour,
        minute = inputState.minute,
        period = inputState.period,
        isComplete = inputState.isComplete,
        subInputFocus = inputState.subInputFocus;
  const inputRefs = {
    HOUR: (0, _react.useRef)(null),
    MINUTE: (0, _react.useRef)(null),
    NONE: (0, _react.useRef)(null),
    PERIOD: (0, _react.useRef)(null)
  };

  const handleValidKeyDown = () => {
    dispatch({
      type: 'INCREMENT_CHAR_COUNT'
    });

    if (inputState.charCount > 0) {
      dispatch({
        type: 'FOCUS_NEXT_FIELD'
      });
    }
  };

  const handleDelete = setStateCB => {
    onChange && onChange(undefined);
    setStateCB();
  };

  const handleHourKeyDown = e => {
    const clearHourField = () => {
      dispatch({
        payload: '',
        type: 'SET_HOUR_VALUE'
      });
      dispatch({
        type: 'RESET_CHAR_COUNT'
      });
    };

    if (isNumericKey(e)) {
      const value = (0, _utils.parseBase10Int)(inputState.charCount === 1 ? `${hour}${e.key}` : e.key);

      if (value < 24) {
        if (format === '12h' && value > 12) {
          dispatch({
            payload: (0, _utils.formatTimeString)(value - 12),
            type: 'SET_HOUR_VALUE'
          });
          dispatch({
            payload: 'PM',
            type: 'SET_PERIOD_VALUE'
          });
        } else {
          dispatch({
            payload: (0, _utils.formatTimeString)(value),
            type: 'SET_HOUR_VALUE'
          });
        }

        handleValidKeyDown();
      } else {
        clearHourField();
      }
    } else if (isArrowKey(e)) {
      const max = format === '12h' ? 12 : 23;
      const min = format === '12h' ? 1 : 0;
      dispatch({
        payload: cycleValue(hour, e.key, max, min),
        type: 'SET_HOUR_VALUE'
      });
    } else if (isDeleteKey(e)) {
      handleDelete(clearHourField);
    }
  };

  const handleMinuteKeyDown = e => {
    const clearMinuteField = () => {
      dispatch({
        payload: '',
        type: 'SET_MINUTE_VALUE'
      });
      dispatch({
        type: 'RESET_CHAR_COUNT'
      });
    };

    if (isNumericKey(e)) {
      const value = (0, _utils.parseBase10Int)(inputState.charCount === 1 ? `${minute}${e.key}` : e.key);

      if (value < 60) {
        dispatch({
          payload: (0, _utils.formatTimeString)(value),
          type: 'SET_MINUTE_VALUE'
        });
        handleValidKeyDown();
      } else {
        clearMinuteField();
      }
    } else if (isArrowKey(e)) {
      dispatch({
        payload: cycleValue(minute, e.key, 59, 0),
        type: 'SET_MINUTE_VALUE'
      });
    } else if (isDeleteKey(e)) {
      handleDelete(clearMinuteField);
    }
  };

  const handlePeriodKeyDown = e => {
    const clearPeriodField = () => {
      dispatch({
        payload: '',
        type: 'SET_PERIOD_VALUE'
      });
      dispatch({
        type: 'RESET_CHAR_COUNT'
      });
    };

    const key = e.key.toUpperCase();

    if (key === 'P' || key === 'A') {
      dispatch({
        payload: `${key}M`,
        type: 'SET_PERIOD_VALUE'
      });
      handleValidKeyDown();
    } else if (isArrowKey(e)) {
      const nextPeriod = period === 'PM' ? 'AM' : 'PM';
      dispatch({
        payload: nextPeriod,
        type: 'SET_PERIOD_VALUE'
      });
    } else if (isDeleteKey(e)) {
      handleDelete(clearPeriodField);
    }
  };

  const handleHourFocus = () => dispatch({
    payload: 'HOUR',
    type: 'SET_FOCUS'
  });

  const handleMinuteFocus = () => dispatch({
    payload: 'MINUTE',
    type: 'SET_FOCUS'
  });

  const handlePeriodFocus = () => dispatch({
    payload: 'PERIOD',
    type: 'SET_FOCUS'
  });

  const handleBlur = () => {
    dispatch({
      payload: 'NONE',
      type: 'SET_FOCUS'
    });
    dispatch({
      type: 'RESET_CHAR_COUNT'
    });
  };

  (0, _react.useEffect)(() => {
    const ref = inputRefs[subInputFocus || ''];

    if (ref.current) {
      ref.current.focus();
    }
  }, [subInputFocus]);
  (0, _react.useEffect)(() => {
    const valueProp = value || defaultValue;

    if ((0, _utils.isValidTime)(valueProp)) {
      const _parseValue = parseValue(format, valueProp),
            _parseValue2 = _slicedToArray(_parseValue, 3),
            newHour = _parseValue2[0],
            newMinute = _parseValue2[1],
            newPeriod = _parseValue2[2];

      hour !== newHour && dispatch({
        payload: newHour,
        type: 'SET_HOUR_VALUE'
      });
      minute !== newMinute && dispatch({
        payload: newMinute,
        type: 'SET_MINUTE_VALUE'
      });
      period !== newPeriod && dispatch({
        payload: newPeriod,
        type: 'SET_PERIOD_VALUE'
      });
    } else {
      onValidationFail && onValidationFail(valueProp);
      console.error(`Invalid time ("${valueProp}") passed to <InputTime />. Value should be formatted as a 24-hour string (e.g. value="02:00" or value="23:15").`);
    }
  }, [value]);
  (0, _react.useEffect)(() => {
    if (isComplete) {
      const newValue = format === '12h' ? convert12To24HrString(`${hour}:${minute} ${period}`) : `${hour}:${minute}`;

      if (newValue !== value) {
        onChange && onChange(`${newValue}`);
      }
    }
  }, [isComplete, hour, minute, period]);
  return _react.default.createElement("div", {
    className: `${className} ${disabled && 'disabled'}`,
    ref: ref,
    onFocus: onFocus,
    onBlur: onBlur,
    "aria-invalid": validationType === 'error' ? 'true' : undefined,
    "aria-describedby": ariaDescribedby,
    "aria-labelledby": ariaLabelledby,
    "aria-disabled": disabled
  }, _react.default.createElement(StyledInput, _extends({
    id: id,
    value: hour,
    onKeyDown: readOnly ? _noop.default : handleHourKeyDown,
    onFocus: handleHourFocus,
    onBlur: handleBlur,
    onChange: _noop.default,
    ref: inputRefs.HOUR,
    "data-testid": "input-hour",
    disabled: disabled,
    readOnly: readOnly,
    required: required
  }, (0, _InputProps.getAutoFocusProps)(autoFocus))), _react.default.createElement("div", null, ":"), _react.default.createElement(StyledInput, {
    value: minute,
    onKeyDown: readOnly ? _noop.default : handleMinuteKeyDown,
    onFocus: handleMinuteFocus,
    onBlur: handleBlur,
    onChange: _noop.default,
    ref: inputRefs.MINUTE,
    "data-testid": "input-minute",
    disabled: disabled,
    readOnly: readOnly,
    required: required
  }), format === '12h' ? _react.default.createElement(StyledInput, {
    value: period,
    onKeyDown: readOnly ? _noop.default : handlePeriodKeyDown,
    onFocus: handlePeriodFocus,
    onBlur: handleBlur,
    onChange: _noop.default,
    ref: inputRefs.PERIOD,
    "data-testid": "input-period",
    disabled: disabled,
    readOnly: readOnly,
    required: required
  }) : _react.default.createElement("span", null), validationType && _react.default.createElement(_InputText.ErrorIcon, null));
});

const StyledInput = _styledComponents.default.input.withConfig({
  shouldForwardProp: _designTokens.shouldForwardProp
}).attrs(() => ({
  maxLength: 2,
  placeholder: '--',
  type: 'text'
})).withConfig({
  displayName: "InputTime__StyledInput",
  componentId: "plt6tg-0"
})(["", " font-family:inherit;font-size:", ";height:34px;line-height:", ";padding:0;text-align:center;width:1.25rem;&:focus{background:", ";}"], _innerInputStyle.innerInputStyle, props => props.theme.fontSizes.small, ({
  theme
}) => theme.lineHeights.medium, ({
  theme
}) => theme.colors.keyAccent);

const InputTime = (0, _styledComponents.default)(InputTimeInternal).withConfig({
  displayName: "InputTime",
  componentId: "plt6tg-1"
})(["", " ", " align-items:center;display:inline-grid;grid-gap:0.15rem;grid-template-columns:auto auto auto auto 1fr;padding:0 ", ";", "{justify-self:end;}&:focus-within{", "}&:hover{", "}&.disabled{", "}", ""], _simple.simpleLayoutCSS, _InputText.inputCSS, ({
  theme
}) => theme.space.xsmall, _InputText.ErrorIcon, _InputText.inputTextFocus, _InputText.inputTextHover, _InputText.inputTextDisabled, _InputText.inputTextValidation);
exports.InputTime = InputTime;
//# sourceMappingURL=InputTime.js.map