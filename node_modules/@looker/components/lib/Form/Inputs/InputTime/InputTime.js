function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import "core-js/modules/es.array.map.js";
import "core-js/modules/es.string.split.js";
import "core-js/modules/es.regexp.exec.js";
import "core-js/modules/es.array.includes.js";
import "core-js/modules/es.string.includes.js";
import "core-js/modules/es.string.replace.js";
import "core-js/modules/es.array.concat.js";
import "core-js/modules/es.string.small.js";
import "core-js/modules/es.object.define-property.js";
import "core-js/modules/es.object.keys.js";
import "core-js/modules/es.symbol.js";
import "core-js/modules/es.array.filter.js";
import "core-js/modules/es.object.get-own-property-descriptor.js";
import "core-js/modules/es.array.for-each.js";
import "core-js/modules/web.dom-collections.for-each.js";
import "core-js/modules/es.object.get-own-property-descriptors.js";
import "core-js/modules/es.object.define-properties.js";
import "core-js/modules/es.array.is-array.js";
import "core-js/modules/es.symbol.description.js";
import "core-js/modules/es.object.to-string.js";
import "core-js/modules/es.symbol.iterator.js";
import "core-js/modules/es.string.iterator.js";
import "core-js/modules/es.array.iterator.js";
import "core-js/modules/web.dom-collections.iterator.js";
import "core-js/modules/es.array.slice.js";
import "core-js/modules/es.function.name.js";
import "core-js/modules/es.array.from.js";
import "core-js/modules/es.object.assign.js";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React, { forwardRef, useReducer, useEffect, useRef } from 'react';
import { shouldForwardProp } from '@looker/design-tokens';
import styled from 'styled-components';
import noop from 'lodash/noop';
import add from 'lodash/add';
import subtract from 'lodash/subtract';
import { inputTextHover, inputTextFocus, inputTextDisabled, inputTextValidation, inputCSS, ErrorIcon } from '../InputText';
import { innerInputStyle } from '../innerInputStyle';
import { simpleLayoutCSS } from '../../../Layout/utils/simple';
import { getAutoFocusProps } from '../InputProps';
import { formatTimeString, parseBase10Int, isValidTime } from './utils';
var initialState = {
  charCount: 0,
  format: '12h',
  hour: '',
  isComplete: false,
  minute: '',
  period: '',
  subInputFocus: 'NONE'
};

var isNumericKey = function isNumericKey(e) {
  return e.keyCode >= 48 && e.keyCode <= 57 || e.keyCode >= 96 && e.keyCode <= 105;
};

var isArrowKey = function isArrowKey(e) {
  return e.key === 'ArrowUp' || e.key === 'ArrowDown';
};

var isDeleteKey = function isDeleteKey(e) {
  return e.key === 'Backspace' || e.key === 'Delete';
};

var selectNextInput = function selectNextInput(current) {
  switch (current) {
    case 'HOUR':
      return 'MINUTE';

    case 'MINUTE':
      return 'PERIOD';

    case 'PERIOD':
      return 'NONE';

    default:
      return 'NONE';
  }
};

var isInputComplete = function isInputComplete(_ref) {
  var format = _ref.format,
      hour = _ref.hour,
      minute = _ref.minute,
      period = _ref.period;

  if (format === '12h') {
    return !!(hour.length && minute.length && period.length);
  }

  return !!(hour.length && minute.length);
};

var reducer = function reducer(state, action) {
  var payload = action.payload,
      type = action.type;
  var inputValues = {
    format: state.format,
    hour: state.hour,
    minute: state.minute,
    period: state.period
  };

  switch (type) {
    case 'SET_FOCUS':
      return _objectSpread(_objectSpread({}, state), {}, {
        subInputFocus: payload
      });

    case 'FOCUS_NEXT_FIELD':
      return _objectSpread(_objectSpread({}, state), {}, {
        subInputFocus: selectNextInput(state.subInputFocus)
      });

    case 'INCREMENT_CHAR_COUNT':
      return _objectSpread(_objectSpread({}, state), {}, {
        charCount: state.charCount + 1
      });

    case 'RESET_CHAR_COUNT':
      return _objectSpread(_objectSpread({}, state), {}, {
        charCount: 0
      });

    case 'SET_HOUR_VALUE':
      return _objectSpread(_objectSpread({}, state), {}, {
        hour: payload,
        isComplete: isInputComplete(_objectSpread(_objectSpread({}, inputValues), {}, {
          hour: payload
        }))
      });

    case 'SET_MINUTE_VALUE':
      return _objectSpread(_objectSpread({}, state), {}, {
        isComplete: isInputComplete(_objectSpread(_objectSpread({}, inputValues), {}, {
          minute: payload
        })),
        minute: payload
      });

    case 'SET_PERIOD_VALUE':
      return _objectSpread(_objectSpread({}, state), {}, {
        isComplete: isInputComplete(_objectSpread(_objectSpread({}, inputValues), {}, {
          period: payload
        })),
        period: payload
      });

    default:
      return state;
  }
};

var cycleValue = function cycleValue(currentValue, key, max, min) {
  var transform = key === 'ArrowUp' ? add : subtract;
  var newValue = transform(parseBase10Int(currentValue), 1);

  if (newValue < min) {
    return formatTimeString(max);
  } else if (newValue > max) {
    return formatTimeString(min);
  } else {
    return formatTimeString(newValue);
  }
};

var parseValue = function parseValue(format) {
  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  if (value.length) {
    var _value$split$map = value.split(':').map(parseBase10Int),
        _value$split$map2 = _slicedToArray(_value$split$map, 2),
        hr24 = _value$split$map2[0],
        minute = _value$split$map2[1];

    var hr12 = hr24 <= 12 ? hr24 : hr24 - 12;
    var period = hr24 >= 12 ? 'PM' : 'AM';
    return [formatTimeString(format === '12h' ? hr12 : hr24), formatTimeString(minute), period];
  }

  return ['', '', ''];
};

export var convert12To24HrString = function convert12To24HrString(value) {
  var period = value.includes('P') ? 'PM' : 'AM';
  var numericTime = value.replace(/[APM]/gi, '');

  var _numericTime$split$ma = numericTime.split(':').map(parseBase10Int),
      _numericTime$split$ma2 = _slicedToArray(_numericTime$split$ma, 2),
      _numericTime$split$ma3 = _numericTime$split$ma2[0],
      hour = _numericTime$split$ma3 === void 0 ? 0 : _numericTime$split$ma3,
      _numericTime$split$ma4 = _numericTime$split$ma2[1],
      minute = _numericTime$split$ma4 === void 0 ? 0 : _numericTime$split$ma4;

  var hr24;

  if (period === 'AM' && hour === 12) {
    hr24 = 0;
  } else if (period === 'PM' && hour < 12) {
    hr24 = hour + 12;
  } else {
    hr24 = hour;
  }

  return "".concat(formatTimeString(hr24), ":").concat(formatTimeString(minute));
};
var InputTimeInternal = forwardRef(function (_ref2, ref) {
  var className = _ref2.className,
      defaultValue = _ref2.defaultValue,
      ariaDescribedby = _ref2['aria-describedby'],
      ariaLabelledby = _ref2['aria-labelledby'],
      autoFocus = _ref2.autoFocus,
      disabled = _ref2.disabled,
      _ref2$format = _ref2.format,
      format = _ref2$format === void 0 ? '12h' : _ref2$format,
      id = _ref2.id,
      onChange = _ref2.onChange,
      readOnly = _ref2.readOnly,
      onBlur = _ref2.onBlur,
      onFocus = _ref2.onFocus,
      onValidationFail = _ref2.onValidationFail,
      required = _ref2.required,
      validationType = _ref2.validationType,
      value = _ref2.value;

  var _useReducer = useReducer(reducer, _objectSpread(_objectSpread({}, initialState), {}, {
    format: format
  })),
      _useReducer2 = _slicedToArray(_useReducer, 2),
      inputState = _useReducer2[0],
      dispatch = _useReducer2[1];

  var hour = inputState.hour,
      minute = inputState.minute,
      period = inputState.period,
      isComplete = inputState.isComplete,
      subInputFocus = inputState.subInputFocus;
  var inputRefs = {
    HOUR: useRef(null),
    MINUTE: useRef(null),
    NONE: useRef(null),
    PERIOD: useRef(null)
  };

  var handleValidKeyDown = function handleValidKeyDown() {
    dispatch({
      type: 'INCREMENT_CHAR_COUNT'
    });

    if (inputState.charCount > 0) {
      dispatch({
        type: 'FOCUS_NEXT_FIELD'
      });
    }
  };

  var handleDelete = function handleDelete(setStateCB) {
    onChange && onChange(undefined);
    setStateCB();
  };

  var handleHourKeyDown = function handleHourKeyDown(e) {
    var clearHourField = function clearHourField() {
      dispatch({
        payload: '',
        type: 'SET_HOUR_VALUE'
      });
      dispatch({
        type: 'RESET_CHAR_COUNT'
      });
    };

    if (isNumericKey(e)) {
      var _value = parseBase10Int(inputState.charCount === 1 ? "".concat(hour).concat(e.key) : e.key);

      if (_value < 24) {
        if (format === '12h' && _value > 12) {
          dispatch({
            payload: formatTimeString(_value - 12),
            type: 'SET_HOUR_VALUE'
          });
          dispatch({
            payload: 'PM',
            type: 'SET_PERIOD_VALUE'
          });
        } else {
          dispatch({
            payload: formatTimeString(_value),
            type: 'SET_HOUR_VALUE'
          });
        }

        handleValidKeyDown();
      } else {
        clearHourField();
      }
    } else if (isArrowKey(e)) {
      var max = format === '12h' ? 12 : 23;
      var min = format === '12h' ? 1 : 0;
      dispatch({
        payload: cycleValue(hour, e.key, max, min),
        type: 'SET_HOUR_VALUE'
      });
    } else if (isDeleteKey(e)) {
      handleDelete(clearHourField);
    }
  };

  var handleMinuteKeyDown = function handleMinuteKeyDown(e) {
    var clearMinuteField = function clearMinuteField() {
      dispatch({
        payload: '',
        type: 'SET_MINUTE_VALUE'
      });
      dispatch({
        type: 'RESET_CHAR_COUNT'
      });
    };

    if (isNumericKey(e)) {
      var _value2 = parseBase10Int(inputState.charCount === 1 ? "".concat(minute).concat(e.key) : e.key);

      if (_value2 < 60) {
        dispatch({
          payload: formatTimeString(_value2),
          type: 'SET_MINUTE_VALUE'
        });
        handleValidKeyDown();
      } else {
        clearMinuteField();
      }
    } else if (isArrowKey(e)) {
      dispatch({
        payload: cycleValue(minute, e.key, 59, 0),
        type: 'SET_MINUTE_VALUE'
      });
    } else if (isDeleteKey(e)) {
      handleDelete(clearMinuteField);
    }
  };

  var handlePeriodKeyDown = function handlePeriodKeyDown(e) {
    var clearPeriodField = function clearPeriodField() {
      dispatch({
        payload: '',
        type: 'SET_PERIOD_VALUE'
      });
      dispatch({
        type: 'RESET_CHAR_COUNT'
      });
    };

    var key = e.key.toUpperCase();

    if (key === 'P' || key === 'A') {
      dispatch({
        payload: "".concat(key, "M"),
        type: 'SET_PERIOD_VALUE'
      });
      handleValidKeyDown();
    } else if (isArrowKey(e)) {
      var nextPeriod = period === 'PM' ? 'AM' : 'PM';
      dispatch({
        payload: nextPeriod,
        type: 'SET_PERIOD_VALUE'
      });
    } else if (isDeleteKey(e)) {
      handleDelete(clearPeriodField);
    }
  };

  var handleHourFocus = function handleHourFocus() {
    return dispatch({
      payload: 'HOUR',
      type: 'SET_FOCUS'
    });
  };

  var handleMinuteFocus = function handleMinuteFocus() {
    return dispatch({
      payload: 'MINUTE',
      type: 'SET_FOCUS'
    });
  };

  var handlePeriodFocus = function handlePeriodFocus() {
    return dispatch({
      payload: 'PERIOD',
      type: 'SET_FOCUS'
    });
  };

  var handleBlur = function handleBlur() {
    dispatch({
      payload: 'NONE',
      type: 'SET_FOCUS'
    });
    dispatch({
      type: 'RESET_CHAR_COUNT'
    });
  };

  useEffect(function () {
    var ref = inputRefs[subInputFocus || ''];

    if (ref.current) {
      ref.current.focus();
    }
  }, [subInputFocus]);
  useEffect(function () {
    var valueProp = value || defaultValue;

    if (isValidTime(valueProp)) {
      var _parseValue = parseValue(format, valueProp),
          _parseValue2 = _slicedToArray(_parseValue, 3),
          newHour = _parseValue2[0],
          newMinute = _parseValue2[1],
          newPeriod = _parseValue2[2];

      hour !== newHour && dispatch({
        payload: newHour,
        type: 'SET_HOUR_VALUE'
      });
      minute !== newMinute && dispatch({
        payload: newMinute,
        type: 'SET_MINUTE_VALUE'
      });
      period !== newPeriod && dispatch({
        payload: newPeriod,
        type: 'SET_PERIOD_VALUE'
      });
    } else {
      onValidationFail && onValidationFail(valueProp);
      console.error("Invalid time (\"".concat(valueProp, "\") passed to <InputTime />. Value should be formatted as a 24-hour string (e.g. value=\"02:00\" or value=\"23:15\")."));
    }
  }, [value]);
  useEffect(function () {
    if (isComplete) {
      var newValue = format === '12h' ? convert12To24HrString("".concat(hour, ":").concat(minute, " ").concat(period)) : "".concat(hour, ":").concat(minute);

      if (newValue !== value) {
        onChange && onChange("".concat(newValue));
      }
    }
  }, [isComplete, hour, minute, period]);
  return React.createElement("div", {
    className: "".concat(className, " ").concat(disabled && 'disabled'),
    ref: ref,
    onFocus: onFocus,
    onBlur: onBlur,
    "aria-invalid": validationType === 'error' ? 'true' : undefined,
    "aria-describedby": ariaDescribedby,
    "aria-labelledby": ariaLabelledby,
    "aria-disabled": disabled
  }, React.createElement(StyledInput, _extends({
    id: id,
    value: hour,
    onKeyDown: readOnly ? noop : handleHourKeyDown,
    onFocus: handleHourFocus,
    onBlur: handleBlur,
    onChange: noop,
    ref: inputRefs.HOUR,
    "data-testid": "input-hour",
    disabled: disabled,
    readOnly: readOnly,
    required: required
  }, getAutoFocusProps(autoFocus))), React.createElement("div", null, ":"), React.createElement(StyledInput, {
    value: minute,
    onKeyDown: readOnly ? noop : handleMinuteKeyDown,
    onFocus: handleMinuteFocus,
    onBlur: handleBlur,
    onChange: noop,
    ref: inputRefs.MINUTE,
    "data-testid": "input-minute",
    disabled: disabled,
    readOnly: readOnly,
    required: required
  }), format === '12h' ? React.createElement(StyledInput, {
    value: period,
    onKeyDown: readOnly ? noop : handlePeriodKeyDown,
    onFocus: handlePeriodFocus,
    onBlur: handleBlur,
    onChange: noop,
    ref: inputRefs.PERIOD,
    "data-testid": "input-period",
    disabled: disabled,
    readOnly: readOnly,
    required: required
  }) : React.createElement("span", null), validationType && React.createElement(ErrorIcon, null));
});
var StyledInput = styled.input.withConfig({
  shouldForwardProp: shouldForwardProp
}).attrs(function () {
  return {
    maxLength: 2,
    placeholder: '--',
    type: 'text'
  };
}).withConfig({
  displayName: "InputTime__StyledInput",
  componentId: "plt6tg-0"
})(["", " font-family:inherit;font-size:", ";height:34px;line-height:", ";padding:0;text-align:center;width:1.25rem;&:focus{background:", ";}"], innerInputStyle, function (props) {
  return props.theme.fontSizes.small;
}, function (_ref3) {
  var theme = _ref3.theme;
  return theme.lineHeights.medium;
}, function (_ref4) {
  var theme = _ref4.theme;
  return theme.colors.keyAccent;
});
export var InputTime = styled(InputTimeInternal).withConfig({
  displayName: "InputTime",
  componentId: "plt6tg-1"
})(["", " ", " align-items:center;display:inline-grid;grid-gap:0.15rem;grid-template-columns:auto auto auto auto 1fr;padding:0 ", ";", "{justify-self:end;}&:focus-within{", "}&:hover{", "}&.disabled{", "}", ""], simpleLayoutCSS, inputCSS, function (_ref5) {
  var theme = _ref5.theme;
  return theme.space.xsmall;
}, ErrorIcon, inputTextFocus, inputTextHover, inputTextDisabled, inputTextValidation);
//# sourceMappingURL=InputTime.js.map