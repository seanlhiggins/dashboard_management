"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseResponse = exports.BrowserTransport = exports.BrowserCryptoHash = void 0;

var _readableStream = require("readable-stream");

var _transport = require("./transport");

var _baseTransport = require("./baseTransport");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

class BrowserCryptoHash {
  arrayToHex(array) {
    return Array.from(array).map(b => b.toString(16).padStart(2, '0')).join('');
  }

  fromBase64(str) {
    return atob(str).split('').map(function (c) {
      return c.charCodeAt(0);
    });
  }

  secureRandom(byteCount) {
    var bytes = new Uint8Array(byteCount);
    window.crypto.getRandomValues(bytes);
    return this.arrayToHex(bytes);
  }

  sha256Hash(message) {
    return _asyncToGenerator(function* () {
      var msgUint8 = new TextEncoder().encode(message);
      var hashBuffer = yield window.crypto.subtle.digest('SHA-256', msgUint8);
      return (0, _transport.safeBase64)(new Uint8Array(hashBuffer));
    })();
  }

}

exports.BrowserCryptoHash = BrowserCryptoHash;

class BrowserTransport extends _baseTransport.BaseTransport {
  constructor(options) {
    super(options);
    this.options = options;
  }

  static supportsPerformance() {
    return !!(performance && performance.mark && performance.measure);
  }

  static get trackPerformance() {
    return this._trackPerf;
  }

  static set trackPerformance(value) {
    this._trackPerf = value && BrowserTransport.supportsPerformance();
  }

  static mark(name, tag) {
    if (this.trackPerformance) {
      var mark = "".concat(name, "-").concat(tag);
      performance.mark(mark);
      return mark;
    }

    return '';
  }

  static markName(url) {
    if (!this.trackPerformance) return '';
    var entries = performance.getEntriesByName(url, 'resource');

    if (entries.length > 0) {
      var last = entries[entries.length - 1];
      return "".concat(url, "-").concat(last.startTime);
    }

    return url;
  }

  static markStart(name) {
    return BrowserTransport.mark(name, BrowserTransport.startMark);
  }

  static markEnd(url, startName) {
    if (this.trackPerformance) {
      var measureName = this.markName(url);
      var end = BrowserTransport.mark(measureName, BrowserTransport.endMark);
      performance.measure(measureName, startName, end);
      performance.clearMarks(startName);
      performance.clearMarks(end);
      return measureName;
    }

    return '';
  }

  rawRequest(method, path, queryParams, body, authenticator, options) {
    var _this = this;

    return _asyncToGenerator(function* () {
      options = _objectSpread(_objectSpread({}, _this.options), options);

      var requestPath = _this.makeUrl(path, options, queryParams);

      var props = yield _this.initRequest(method, requestPath, body, authenticator, options);
      var req = fetch(props.url, props);
      var res = yield req;
      var started = BrowserTransport.markStart(BrowserTransport.markName(requestPath));
      var contentType = String(res.headers.get('content-type'));
      var mode = (0, _transport.responseMode)(contentType);
      var responseBody = mode === _transport.ResponseMode.binary ? yield res.blob() : yield res.text();

      if (!('fromRequest' in options)) {
        BrowserTransport.markEnd(requestPath, started);
      }

      return {
        url: requestPath,
        body: responseBody,
        contentType,
        ok: true,
        statusCode: res.status,
        statusMessage: res.statusText,
        startMark: started
      };
    })();
  }

  request(method, path, queryParams, body, authenticator, options) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      try {
        if (BrowserTransport.trackPerformance) {
          options = _objectSpread(_objectSpread({}, options), {
            fromRequest: true
          });
        }

        var res = yield _this2.rawRequest(method, path, queryParams, body, authenticator, options);
        var parsed = yield parseResponse(res);

        if (_this2.ok(res)) {
          return {
            ok: true,
            value: parsed
          };
        } else {
          return {
            error: parsed,
            ok: false
          };
        }
      } catch (e) {
        var error = {
          message: typeof e.message === 'string' ? e.message : "The SDK call was not successful. The error was '".concat(e, "'."),
          type: 'sdk_error'
        };
        return {
          error,
          ok: false
        };
      }
    })();
  }

  initRequest(method, path, body, authenticator, options) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      var _options;

      var agentTag = ((_options = options) === null || _options === void 0 ? void 0 : _options.agentTag) || _transport.agentPrefix;
      options = options ? _objectSpread(_objectSpread({}, _this3.options), options) : _this3.options;
      var headers = {
        [_transport.LookerAppId]: agentTag
      };

      if (options && options.headers) {
        Object.entries(options.headers).forEach((_ref) => {
          var [key, val] = _ref;
          headers[key] = val;
        });
      }

      if (!body) {
        body = undefined;
      } else {
        if (typeof body !== 'string') {
          body = JSON.stringify(body);
          headers['Content-Type'] = 'application/json';
        }
      }

      var props = {
        body,
        credentials: 'same-origin',
        headers,
        method,
        url: path
      };

      if (authenticator) {
        props = yield authenticator(props);
      }

      return props;
    })();
  }

  stream(callback, method, path, queryParams, body, authenticator, options) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      options = options ? _objectSpread(_objectSpread({}, _this4.options), options) : _this4.options;
      var stream = new _readableStream.PassThrough();
      var returnPromise = callback(stream);

      var requestPath = _this4.makeUrl(path, options, queryParams);

      var props = yield _this4.initRequest(method, requestPath, body, authenticator, options);
      (0, _transport.trace)("[stream] attempting to stream via download url", props);
      return Promise.reject(Error("Streaming for".concat(returnPromise ? 'callback' : '', " ").concat(props.method, " ").concat(props.requestPath, " is not implemented")));
    })();
  }

}

exports.BrowserTransport = BrowserTransport;

_defineProperty(BrowserTransport, "_trackPerf", false);

_defineProperty(BrowserTransport, "startMark", 'A');

_defineProperty(BrowserTransport, "endMark", 'B');

var parseResponse = function () {
  var _ref2 = _asyncToGenerator(function* (res) {
    var perfMark = res.startMark || '';

    if (res.contentType.match(/application\/json/g)) {
      try {
        var result = JSON.parse(yield res.body);
        BrowserTransport.markEnd(res.url, perfMark);
        return result;
      } catch (error) {
        BrowserTransport.markEnd(res.url, perfMark);
        return Promise.reject(error);
      }
    } else if (res.contentType === 'text' || res.contentType.startsWith('text/')) {
      var _result = res.body.toString();

      BrowserTransport.markEnd(res.url, perfMark);
      return _result;
    } else {
      try {
        BrowserTransport.markEnd(res.url, perfMark);
        return res.body;
      } catch (error) {
        BrowserTransport.markEnd(res.url, perfMark);
        return Promise.reject(error);
      }
    }
  });

  return function parseResponse(_x) {
    return _ref2.apply(this, arguments);
  };
}();

exports.parseResponse = parseResponse;
//# sourceMappingURL=browserTransport.js.map